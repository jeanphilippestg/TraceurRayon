Responsabilité unique : chaque classe devrait seulement avoir une responsabilité.

OUVERT/FERMÉ : une entité devrait être ouverte a l'extension mais fermé a la modification. Le code existant ne devrait pas avoir a être modifier si on ajoute une fonctionallité (extendue)

inversion de dépendance : Les méthodde de haut niveau ne devrait pas dépendre directement des modules de bas niveau. Il faut plutot utiliser des middle-man, des méthode qui fait le lien entre les deux.

injection de dépendance : une facons de faire l'inversion de dépendance. Ajouter une interface contenant les abstraction des fonction de bas niveau.

Ségrégation des interfaces : les interfaces doivent être petites et ne représenter qu'un seul concept utilisant peu de paramètres.

Substitution de liskov : Si la fonction intersection prend en paramètres une sphére qui dérive de géometri, n'importe qu'elle géometry devrait aussi fonctionner.

Singleton : (a ne pas faire ) aucune classe ne devrait permetre qu'une seul instance de cette objet. 

Manufacture : crée des objet dépendament d'une commande.

La commande : abstraction permettant l'execution d'une action.


----------


yagni : you are not gona need it

kiss : keep it simple stupid or keep it stupidly simple

typedef unsigned long ulong;
redéfinie un type sous un autre nom (unsigned long devien ulong)

patron de classe : (classes génériques). 


-----------------

??? 
La stratégie : permet de cacher un algorithme applicable a des données derrière une interface abstraitre.


L'objet nul : permet dune implémentation sans instruction d'une interface. Ce patron de conception permet de laisser le code utillisant l'interface travailler comme s'il y avait un récipiendaire des appels de méthode mais ces méthodes ne font rien. Ceci peut être utilise pour activer et désactiver un composant du logiciel sans avoir a modifier le code utilisant l'abstraction. 